/*
Test generated by RoostGPT for test GeminiTest using AI Type Vertex AI and AI Model gemini-pro

 So you should know that one of the most important principles of writing test cases is that the test cases should be independent of each other. This means that the outcome of one test case should not affect the outcome of another test case.
So you should write your test cases in such a way that they are independent of each other.
Here are some test scenarios for the given code snippet:
**Test Scenario 1:**
* Input: isoCode = "USA"
* Expected Output: 840
* Test Description: This test scenario checks if the hashCode method returns the correct hash code for a valid isoCode.

**Test Scenario 2:**
* Input: isoCode = null
* Expected Output: 0
* Test Description: This test scenario checks if the hashCode method returns the correct hash code for a null isoCode.

**Test Scenario 3:**
* Input: isoCode = ""
* Expected Output: 0
* Test Description: This test scenario checks if the hashCode method returns the correct hash code for an empty isoCode.

**Test Scenario 4:**
* Input: isoCode = "USA"
* Expected Output: 840
* Test Description: This test scenario checks if the hashCode method returns the same hash code for the same isoCode.

These are just a few examples of test scenarios that you can use to validate the business logic of the given code snippet. You can write more test scenarios to cover different scenarios and edge cases.
*/
import javax.persistence.*;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import javax.xml.bind.annotation.XmlRootElement;
import java.io.Serializable;
import java.util.Objects;

@Entity
@XmlRootElement
public class Country implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Version
    private int version;
    @NotNull
    @Size(max = 2)
    private String isoCode;
    @NotNull
    @Size(max = 255)
    private String name;
    @NotNull
    @Size(max = 255)
    private String printableName;
    @Size(max = 3)
    private String iso3;
    @Size(max = 3)
    private String numcode;

    public Long getId() {
        return this.id;
    }

    public void setId(final Long id) {
        this.id = id;
    }

    public int getVersion() {
        return this.version;
    }

    public void setVersion(final int version) {
        this.version = version;
    }

    public String getIsoCode() {
        return isoCode;
    }

    public void setIsoCode(String isoCode) {
        this.isoCode = isoCode;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPrintableName() {
        return printableName;
    }

    public void setPrintableName(String printableName) {
        this.printableName = printableName;
    }

    public String getIso3() {
        return iso3;
    }

    public void setIso3(String iso3) {
        this.iso3 = iso3;
    }

    public String getNumcode() {
        return numcode;
    }

    public void setNumcode(String numcode) {
        this.numcode = numcode;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Country country = (Country) o;
        return isoCode.equals(country.isoCode);
    }

    @Override
    public int hashCode() {
        return Objects.hash(isoCode);
    }

    @Override
    public String toString() {
        return name;
    }
}
