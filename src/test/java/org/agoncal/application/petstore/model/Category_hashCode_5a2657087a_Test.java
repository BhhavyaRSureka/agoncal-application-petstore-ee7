/*
Test generated by RoostGPT for test GeminiTest using AI Type Vertex AI and AI Model gemini-pro

 Please provide test scenarios to validate the business logic of the given code snippet.

The given code snippet is `hashCode()` method of a class that is annotated with `@Entity` and `@Table` annotations.
The `hashCode()` method is used to generate a hash code for the object.
The hash code is used to identify the object in a hash table or other data structure that uses hashing.
The `hashCode()` method is defined in the `Object` class, and it is overridden in the given class to generate a hash code based on the `name` field of the object.

Here are some test scenarios to validate the business logic of the given code snippet:

**Scenario 1:**
- Given two objects with the same `name` field, the `hashCode()` method should return the same hash code for both objects.

**Scenario 2:**
- Given two objects with different `name` fields, the `hashCode()` method should return different hash codes for the two objects.

**Scenario 3:**
- Given an object with a `null` `name` field, the `hashCode()` method should return a hash code that is different from the hash code of an object with a non-`null` `name` field.

**Scenario 4:**
- Given an object with a `name` field that is an empty string, the `hashCode()` method should return a hash code that is different from the hash code of an object with a non-empty `name` field.

**Scenario 5:**
- Given an object with a `name` field that contains special characters, the `hashCode()` method should return a hash code that is different from the hash code of an object with a `name` field that does not contain special characters.

**Scenario 6:**
- Given an object with a `name` field that is very long, the `hashCode()` method should return a hash code that is different from the hash code of an object with a `name` field that is short.

**Scenario 7:**
- Given an object with a `name` field that is generated randomly, the `hashCode()` method should return a hash code that is different from the hash code of an object with a `name` field that is not generated randomly.

**Scenario 8:**
- Given an object with a `name` field that is changed, the `hashCode()` method should return a different hash code for the object before and after the change.

**Scenario 9:**
- Given an object with a `name` field that is changed back to its original value, the `hashCode()` method should return the same hash code for the object before and after the change.

These test scenarios should help to validate the business logic of the given code snippet.
*/
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import javax.xml.bind.annotation.XmlRootElement;
import java.io.Serializable;
import java.util.Objects;

class Category_hashCode_5a2657087a_Test {

    @Test
    void sameName_sameHash() {
        Category category1 = new Category("name", "description");
        Category category2 = new Category("name", "description");

        Assertions.assertEquals(category1.hashCode(), category2.hashCode());
    }

    @Test
    void differentName_differentHash() {
        Category category1 = new Category("name1", "description");
        Category category2 = new Category("name2", "description");

        Assertions.assertNotEquals(category1.hashCode(), category2.hashCode());
    }

    @Test
    void nullName_differentHash() {
        Category category1 = new Category("name", "description");
        Category category2 = new Category(null, "description");

        Assertions.assertNotEquals(category1.hashCode(), category2.hashCode());
    }

    @Test
    void emptyName_differentHash() {
        Category category1 = new Category("name", "description");
        Category category2 = new Category("", "description");

        Assertions.assertNotEquals(category1.hashCode(), category2.hashCode());
    }

    @Test
    void specialCharactersInName_differentHash() {
        Category category1 = new Category("name", "description");
        Category category2 = new Category("name!", "description");

        Assertions.assertNotEquals(category1.hashCode(), category2.hashCode());
    }

    @Test
    void longName_differentHash() {
        Category category1 = new Category("name", "description");
        Category category2 = new Category("Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", "description");

        Assertions.assertNotEquals(category1.hashCode(), category2.hashCode());
    }

    @Test
    void randomlyGeneratedName_differentHash() {
        Category category1 = new Category("name", "description");
        Category category2 = new Category(String.valueOf(Math.random()), "description");

        Assertions.assertNotEquals(category1.hashCode(), category2.hashCode());
    }

    @Test
    void nameChanged_differentHash() {
        Category category = new Category("name", "description");
        String oldName = category.getName();
        category.setName("new name");

        Assertions.assertNotEquals(category.hashCode(), Objects.hash(oldName));
    }

    @Test
    void nameChangedBackToOriginal_sameHash() {
        Category category = new Category("name", "description");
        String oldName = category.getName();
        category.setName("new name");
        category.setName(oldName);

        Assertions.assertEquals(category.hashCode(), Objects.hash(oldName));
    }
}
