/*
Test generated by RoostGPT for test GeminiTest using AI Type Vertex AI and AI Model gemini-pro

 You have been asked to write test scenarios for the provided code snippet function `hashCode`. The function `hashCode` is part of the `java.lang.Object` class and is used to generate a hash code for an object. The hash code is a unique identifier for an object and is used by various data structures, such as hash tables and sets, to quickly find and retrieve objects.

**Test Scenario 1:**

* **Objective:** To verify that the `hashCode` function returns the same hash code for two objects that have the same values for the `street1`, `city`, and `zipcode` fields.
* **Input:** Two objects with the same values for the `street1`, `city`, and `zipcode` fields.
* **Expected Output:** The two objects should have the same hash code.

**Test Scenario 2:**

* **Objective:** To verify that the `hashCode` function returns different hash codes for two objects that have different values for the `street1`, `city`, or `zipcode` fields.
* **Input:** Two objects with different values for the `street1`, `city`, or `zipcode` fields.
* **Expected Output:** The two objects should have different hash codes.

**Test Scenario 3:**

* **Objective:** To verify that the `hashCode` function returns the same hash code for two objects that have the same values for the `street1`, `city`, and `zipcode` fields, even if the objects are created at different times.
* **Input:** Two objects with the same values for the `street1`, `city`, and `zipcode` fields, created at different times.
* **Expected Output:** The two objects should have the same hash code.

**Test Scenario 4:**

* **Objective:** To verify that the `hashCode` function returns different hash codes for two objects that have the same values for the `street1`, `city`, and `zipcode` fields, but the objects are of different classes.
* **Input:** Two objects with the same values for the `street1`, `city`, and `zipcode` fields, but the objects are of different classes.
* **Expected Output:** The two objects should have different hash codes.

**Test Scenario 5:**

* **Objective:** To verify that the `hashCode` function returns the same hash code for two objects that have the same values for the `street1`, `city`, and `zipcode` fields, even if the objects are created in different threads.
* **Input:** Two objects with the same values for the `street1`, `city`, and `zipcode` fields, created in different threads.
* **Expected Output:** The two objects should have the same hash code.
*/
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import java.util.Objects;

class Address_hashCode_5a2657087a_Test {

    @ParameterizedTest
    @CsvSource({
            "123 Main St, Anytown, CA 12345, 123 Main St, Anytown, CA 12345, 123 Main St, Anytown, CA 12345",
            "123 Main St, Anytown, CA 12345, 123 Main St, Anytown, CA 12346, 123 Main St, Anytown, CA 12347",
            "123 Main St, Anytown, CA 12345, 123 Main St, Anytown, CA 12345, 123 Main St, Anytown, CA 12345"
    })
    @DisplayName("hashCode should return the same hash code for two objects with the same values for the street1, city, and zipcode fields.")
    void testHashCodeForSameObjects(String address1, String address2, String address3) {
        Address obj1 = new Address(address1);
        Address obj2 = new Address(address2);
        Address obj3 = new Address(address3);

        assertEquals(obj1.hashCode(), obj2.hashCode(), "Hash codes should be equal for objects with same values.");
        assertEquals(obj2.hashCode(), obj3.hashCode(), "Hash codes should be equal for objects with same values.");
    }

    @ParameterizedTest
    @CsvSource({
            "123 Main St, Anytown, CA 12345, 456 Elm St, Anytown, CA 12346, 789 Oak St, Anytown, CA 12347",
            "123 Main St, Anytown, CA 12345, 123 Main St, Anytown, CA 12346, 123 Main St, Anytown, CA 12347",
            "123 Main St, Anytown, CA 12345, 123 Main St, Anytown, CA 12345, 123 Main St, Anytown, CA 12346"
    })
    @DisplayName("hashCode should return different hash codes for two objects with different values for the street1, city, or zipcode fields.")
    void testHashCodeForDifferentObjects(String address1, String address2, String address3) {
        Address obj1 = new Address(address1);
        Address obj2 = new Address(address2);
        Address obj3 = new Address(address3);

        assertNotEquals(obj1.hashCode(), obj2.hashCode(), "Hash codes should not be equal for objects with different values.");
        assertNotEquals(obj2.hashCode(), obj3.hashCode(), "Hash codes should not be equal for objects with different values.");
    }

    @Test
    @DisplayName("hashCode should return the same hash code for two objects with the same values for the street1, city, and zipcode fields, even if the objects are created at different times.")
    void testHashCodeForObjectsCreatedAtDifferentTimes() {
        Address obj1 = new Address("123 Main St, Anytown, CA 12345");
        Address obj2 = new Address("123 Main St, Anytown, CA 12345");

        // Sleep for a second to ensure that the objects are created at different times.
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        assertEquals(obj1.hashCode(), obj2.hashCode(), "Hash codes should be equal for objects with same values, even if created at different times.");
    }

    @Test
    @DisplayName("hashCode should return different hash codes for two objects with the same values for the street1, city, and zipcode fields, but the objects are of different classes.")
    void testHashCodeForObjectsOfDifferentClasses() {
        Address obj1 = new Address("123 Main St, Anytown, CA 12345");
        Object obj2 = new Object();

        assertNotEquals(obj1.hashCode(), obj2.hashCode(), "Hash codes should not be equal for objects of different classes, even if the values are the same.");
    }

    @Test
    @DisplayName("hashCode should return the same hash code for two objects with the same values for the street1, city, and zipcode fields, even if the objects are created in different threads.")
    void testHashCodeForObjectsCreatedInDifferentThreads() {
        Address obj1 = new Address("123 Main St, Anytown, CA 12345");
        Address obj2 = new Address("123 Main St, Anytown, CA 12345");

        Thread thread1 = new Thread(() -> {
            obj1.hashCode();
        });

        Thread thread2 = new Thread(() -> {
            obj2.hashCode();
        });

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        assertEquals(obj1.hashCode(), obj2.hashCode(), "Hash codes should be equal for objects with same values, even if created in different threads.");
    }
}
