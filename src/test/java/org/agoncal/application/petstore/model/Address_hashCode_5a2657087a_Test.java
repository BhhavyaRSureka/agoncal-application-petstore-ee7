/*
Test generated by RoostGPT for test JavaTesting using AI Type Open AI and AI Model gpt-4

Test Scenario 1: Positive scenario
- Test the hashCode() function with valid non-null values for street1, city, and zipcode. The function should return a valid hash code.

Test Scenario 2: Null values
- Test the hashCode() function with null values for street1, city, and zipcode. The function should handle null values and return a valid hash code.

Test Scenario 3: Empty values
- Test the hashCode() function with empty values for street1, city, and zipcode. The function should handle empty values and return a valid hash code.

Test Scenario 4: Large input values
- Test the hashCode() function with large values for street1, city, and zipcode. The function should handle large values and return a valid hash code.

Test Scenario 5: Special characters in input
- Test the hashCode() function with special characters in street1, city, and zipcode. The function should handle special characters and return a valid hash code.

Test Scenario 6: Numeric input values
- Test the hashCode() function with numeric values for street1, city, and zipcode. The function should handle numeric values and return a valid hash code.

Test Scenario 7: Identical input values
- Test the hashCode() function with identical values for street1, city, and zipcode. The function should return the same hash code for identical inputs. 

Test Scenario 8: Different input values
- Test the hashCode() function with different values for street1, city, and zipcode. The function should return different hash codes for different inputs. 

Test Scenario 9: Repeating the same input values
- Test the hashCode() function by repeatedly calling it with the same values for street1, city, and zipcode. The function should consistently return the same hash code for the same inputs. 

Test Scenario 10: Changing the order of input values
- Test the hashCode() function by changing the order of input values for street1, city, and zipcode. The function should return different hash codes when the order of inputs is changed.
*/
package org.agoncal.application.petstore.model;

import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.junit.jupiter.api.Assertions.*;

public class Address_hashCode_5a2657087a_Test {

    @Test
    public void testHashCodeWithValidInput() {
        Address address = new Address("Street1", "City", "Zipcode", new Country());
        int expectedHashCode = Objects.hash("Street1", "City", "Zipcode");
        assertEquals(expectedHashCode, address.hashCode());
    }

    @Test
    public void testHashCodeWithNullInput() {
        Address address = new Address(null, null, null, new Country());
        int expectedHashCode = Objects.hash(null, null, null);
        assertEquals(expectedHashCode, address.hashCode());
    }

    @Test
    public void testHashCodeWithEmptyInput() {
        Address address = new Address("", "", "", new Country());
        int expectedHashCode = Objects.hash("", "", "");
        assertEquals(expectedHashCode, address.hashCode());
    }

    @Test
    public void testHashCodeWithLargeInput() {
        String largeValue = "largeValue".repeat(100);
        Address address = new Address(largeValue, largeValue, largeValue, new Country());
        int expectedHashCode = Objects.hash(largeValue, largeValue, largeValue);
        assertEquals(expectedHashCode, address.hashCode());
    }

    @Test
    public void testHashCodeWithSpecialCharactersInput() {
        String specialCharacters = "#$%^&*";
        Address address = new Address(specialCharacters, specialCharacters, specialCharacters, new Country());
        int expectedHashCode = Objects.hash(specialCharacters, specialCharacters, specialCharacters);
        assertEquals(expectedHashCode, address.hashCode());
    }

    @Test
    public void testHashCodeWithNumericInput() {
        String numericValue = "1234567890";
        Address address = new Address(numericValue, numericValue, numericValue, new Country());
        int expectedHashCode = Objects.hash(numericValue, numericValue, numericValue);
        assertEquals(expectedHashCode, address.hashCode());
    }

    @Test
    public void testHashCodeWithIdenticalInput() {
        String identicalValue = "identicalValue";
        Address address1 = new Address(identicalValue, identicalValue, identicalValue, new Country());
        Address address2 = new Address(identicalValue, identicalValue, identicalValue, new Country());
        assertEquals(address1.hashCode(), address2.hashCode());
    }

    @Test
    public void testHashCodeWithDifferentInput() {
        Address address1 = new Address("Street1", "City", "Zipcode", new Country());
        Address address2 = new Address("Street2", "City2", "Zipcode2", new Country());
        assertNotEquals(address1.hashCode(), address2.hashCode());
    }

    @Test
    public void testHashCodeConsistency() {
        Address address = new Address("Street", "City", "Zipcode", new Country());
        int initialHashCode = address.hashCode();
        for (int i = 0; i < 100; i++) {
            assertEquals(initialHashCode, address.hashCode());
        }
    }

    @Test
    public void testHashCodeWithChangedOrderOfInput() {
        Address address1 = new Address("Street1", "City", "Zipcode", new Country());
        Address address2 = new Address("City", "Zipcode", "Street1", new Country());
        assertNotEquals(address1.hashCode(), address2.hashCode());
    }
}
